"""
Script.

Compare how quickly different 'dF' (multicanonical/transition matrix) simulations converge on
a result for the free energy difference between the two lattices.

Input data is generated by running      ./get_data.sh dF    in an appropriate directory.

Note that multiple simulations with the same simID (set in params.py) will be averaged over,
rather than compared.

Argument variables give the type of comparison to make:
No argument variable: Compares the values and uncertainties on dF for different simulations.
                      They must have run for the same number of sweeps!
                      Input file = "dF_data.txt"

argv[1] == 'std': Compare standard deviation as a function of sweeps for different simulations.
                  Input file = "stdev_series.txt"

argv[1] == 'psi': Compute the speedup function.
                  Input file = "stdev_series.txt"

Run as e.g.     python compare_dF.py std
"""

import numpy as np
import matplotlib.pyplot as plt
from sys import argv, exit

# Import information on input files, simulation data from sim_info.py (make sure it's correct!)
import sim_info

# Generic plot parameters
plt.rc('text', usetex=True)
font = {'family' : 'serif',
        'size' : 14}
plt.rc('font', **font)
colors = ('b', 'g', 'm', 'c')

# Create plot
fig, ax = plt.subplots()
ax.tick_params(direction='in', top=True, right=True)
ax.set_xlabel("Sweeps")
ax.set_ylabel(r"$\log_{10}{(\sigma_{dF)}}$")
ax.set_title("Time series of standard deviation")

# Input file names given as arguments
input_files = argv[1:]
Nfiles = len(input_files)

# Quick check
if Nfiles == 0:
    print "Error: Please provide one or more input files as arguments"
    exit(1)


# Iterate over input files
for ifile in range(Nfiles):

    # Initialise lists
    simID = []
    Ns = []
    dF_stdev = []
    sweeps_per_s = []
    
    # Read input data
    print "Reading data fom file ", input_files[ifile]
    input_data = np.loadtxt(input_files[ifile])
    
    # Look for lines with Ns = -1 in second col
    # These separate data from different simulations
    new_sim_rows = np.where( input_data[:,1] == -1 )[0]
    Nsim = len(new_sim_rows)

    # Separate data from different simulations 
    rlo = 0
    for i in range(Nsim):
        rhi = int(new_sim_rows[i])
        
        simID.append(input_data[rlo,0])
        Ns.append(input_data[rlo,1])
        sweeps_per_s.append(input_data[rlo+1:rhi,0])
        dF_stdev.append(input_data[rlo+1:rhi,1])

        rlo = rhi + 1

  
    unique_sweeps_per_s = []
    dF_stdev_mean = []
    dF_stdev_stderr = []
    unique_Ns = []
    N_repeats_list = []
    unique_simID = np.sort(np.array(list(set(simID)), dtype=int)) # low->high simID
    simID = np.array(simID, dtype=int) # convert to int for usid == sid expression


    # ----------------------------- #
    #  Iterate over unique simID's  #
    # ----------------------------- #
    for usid in unique_simID:

        # Find indices corresponding to repeats to be averaged over
        index_list = [i for i, sid in enumerate(simID) if usid == sid]
        index_list = np.array(index_list)
        i0 = index_list[0]

        # Keep track of the number of sims we're averaging over
        N_repeats = len(index_list)
        N_repeats_list.append(N_repeats)
        print "Averaging over %d simulations for simID: %d (%s)" \
                %(N_repeats, usid, sim_info.sim_labels[usid])

        # Assume repeats have same Ns - pretty safe to assume
        unique_Ns.append(Ns[i0])

        # Skip the averaging if only one sim
        if N_repeats == 1:
            unique_sweeps_per_s.append(sweeps_per_s[i0])
            dF_stdev_rmean.append( dF_stdev[i0] )
            dF_stdev_rstderr.append( np.zeros(len(dF_stdev[i0])) )
            continue

        # Sweeps array taken from simulation with the most sweeps
        max_sweeps = 0
        i_max_sweeps = 0
        for i in index_list:
            if sweeps_per_s[i][-1] > max_sweeps:
                i_max_sweeps = i

        # Require repeats to have been sampled at the same frequency of sweeps
        unique_sweeps_per_s.append( sweeps_per_s[i_max_sweeps])
       
        # Create wierd array so we can take averages over data of different lengths
        max_len = len(sweeps_per_s[i_max_sweeps])
        data_to_average = np.ma.empty( (max_len, N_repeats) ) # (rows=sweeps, cols=sims)
        data_to_average.mask = True

        # Fill in array with stdev values
        for j in range(len(index_list)):
            i = index_list[j]
            this_data = dF_stdev[i]
            data_to_average[:this_data.shape[0],j] = this_data

        # Average over repeats for each value of sweeps
        data_averaged = np.array( data_to_average.mean(axis=1) )
        dF_stdev_mean.append(data_averaged)

        # Append error on the mean to list
        data_stderr = np.array( data_to_average.std(axis=1) ) / np.sqrt(N_repeats)
        dF_stdev_stderr.append( data_stderr )
     
        
    # End loop of unique simID's
    

    # Rename things for convenience and convert to arrays of ints
    Ns = np.array(unique_Ns, dtype=int)
    simID = np.array(unique_simID, dtype=int)
    sweeps_per_s = unique_sweeps_per_s
    Nsim = len(simID) # now this is number of sims after averaging


    # ------------- #
    #  Add to plot  #
    # ------------- #
    # Input file is a key to access dictionary, value describes the simulation
    label = sim_info.file_labels[ input_files[ifile] ]

    i = 0 # int for indexing lists
    for sid in simID: # sorted list of ints, but may have gaps, so not interchangeable with i
        
        # Simulation label and N repeats in legend
        ilabel = sim_info.sim_labels[sid] + " (" + str(N_repeats_list[i]) + " repeats)"
        ilabel = label + ": " + ilabel

        # Log plot is clearer
        logdata = np.log10(dF_stdev_mean[i])
        
        # Propagate errors on logdata
        logdata_plus_err = np.log10(dF_stdev_mean[i] + dF_stdev_stderr[i])
        logdata_err = np.abs(logdata_plus_err - logdata)
        
        # Sometimes it's clearer without the error bars...
        logdata_err = np.zeros(len(logdata))

        ax.errorbar(sweeps_per_s[i], logdata, yerr=logdata_err, fmt='-', label=ilabel)
        i += 1


# End loop over input files


ax.legend()
plt.tight_layout()
plt.show()

