"""
Script.

Compare how quickly different Wang Landau simulations converge their weights.

Input data (wl_data.txt) is generated by running      ./get_data.sh wl
in an appropriate directory.

Note that multiple simulations with the same simID (set in params.py) will be averaged over,
rather than compared.

Argument variables give the type of comparison to make:
No argument variable: Compare the total number of sweeps to achieve convergence to a common
                      'F' value.

argv[1] == 'psi': Compute the speedup function.

Run as e.g.     python compare_wl.py psi
"""

import numpy as np
import matplotlib.pyplot as plt
from sys import argv, exit

import sim_info

plt.rc('text', usetex=True)
font = {'family' : 'serif',
        'size' : 14}
plt.rc('font', **font)


# Input file name
input_file = "wl_data.txt"


# Initialise lists
simID = []
F_final = []
Ns = []
sweeps_all_s = []

# Open file and read data
with open(input_file) as f:
    for line in f:
        
        # Convert line from string to list of floats
        line_float = map(float, line.split())

        # Append single numbers to lists
        simID.append(line_float[0])
        F_final.append(line_float[1])
        Ns.append(line_float[2])

        # Sort out sweeps using numpy arrays and append to lists
        sweeps_array = np.array(line_float[3:])
        sweeps_all_s.append(sweeps_array)

# Check that all simulations have converged to the same F
F_final = np.array(F_final)
if np.min(F_final) != np.max(F_final):
    print "Warning: simulations have converged to different F values"
    exit(1)
F = F_final[0]

# Initialise lists to hold averages over repeats
rep_av_sweeps_all_s = []
rep_av_sweeps_mean = []
rep_av_sweeps_stderr = []

unique_Ns = []
N_repeats = []
unique_simID = np.sort(np.array(list(set(simID)), dtype=int)) # low->high simID
simID = np.array(simID, dtype=int) # convert to int for usid == sid expression
    
# ----------------------------- #
#  Iterate over unique simID's  #
# ----------------------------- #
for usid in unique_simID:

    # Find indices corresponding to repeats to be averaged over
    index_list = [i for i, sid in enumerate(simID) if usid == sid]
    i0 = index_list[0]

    # Keep track of the number of sims we're averaging over
    N_repeats.append(len(index_list))

    print "Averaging over %d simulations for simID: %d (%s)" \
            %(len(index_list), usid, sim_info.sim_labels[usid])

    # Assume repeats have same Ns - pretty safe to assume
    unique_Ns.append(Ns[i0])
    
    # Pull out the relevant values
    data_to_average = [] # store values for each repeat, subdomain
    for i in index_list:
        data_to_average.append(sweeps_all_s[i])
    
    # Data in form (rows, cols) = (repeats, subdoms)
    data_to_average = np.array(data_to_average)

    # Average over repeats, subdoms still separate (useful to see trends)
    rep_av_sweeps_all_s.append( np.mean(data_to_average, axis=0) )
    
    # Average over repeats AND subdoms
    data_to_average = data_to_average.flatten()
    rep_av_sweeps_mean.append( np.mean(data_to_average) )
    rep_av_sweeps_stderr.append( np.std(data_to_average) / np.sqrt(len(data_to_average)) )


# Rename things for convenience and convert to arrays of ints
Ns = np.array(unique_Ns, dtype=int)
simID = np.array(unique_simID, dtype=int)

# Convert averaged data to arrays
rep_av_sweeps_mean = np.array(rep_av_sweeps_mean)
rep_av_sweeps_stderr = np.array(rep_av_sweeps_stderr)

# Number of unique simulations
Nsim = len(simID)


#####################################
## Total sweeps to achieve final F ##
#####################################
if len(argv) == 1:

    fig, ax = plt.subplots()
    ax.tick_params(direction='in', top=True, right=True)
    ax.set_xlabel(sim_info.axis_label)
    ax.set_ylabel("Sweeps to reach $F-1=$ %1.1e" %(F-1))
    ax.set_title("Comparison of Wang Landau simulations")

    # Plot mean and standard error
    fake_xticks = np.arange(Nsim)
    ax.bar(fake_xticks, rep_av_sweeps_mean)
    ax.errorbar(fake_xticks, rep_av_sweeps_mean, yerr=rep_av_sweeps_stderr, fmt='ko')

    # Plot a little line to show any trends in subdomain convergence
    xwidth = 0.4
    for i in range(Nsim):
        x = np.linspace(-xwidth, xwidth, Ns[i]) + fake_xticks[i]
        ax.plot(x, rep_av_sweeps_all_s[i], 'r-')

    # Replace x axis with simID string
    ax.set_xticks(fake_xticks)
    ax.set_xticklabels(sim_info.sim_labels)

    # y axis ticks in scientific notation
    ax.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

    # -------------------- #
    #  Save averaged data  #
    # -------------------- #
    data_to_save = np.zeros( (Nsim, 4) )
    data_to_save[:,0] = simID
    data_to_save[:,1] = np.array(N_repeats)
    data_to_save[:,2] = rep_av_sweeps_mean
    data_to_save[:,3] = rep_av_sweeps_stderr
    np.savetxt("averaged_wl_data.txt", data_to_save)

#######################################
## Compute and plot speedup function ##
#######################################
elif argv[1] == 'psi':

    # Maybe we calculate speed relative to Np =/= 1 processors
    min_Ns = np.min(Ns)
    print "Computing speedup function defined as:  psi(Np) = X(%d)/X(Np),  (X: sweeps)" %min_Ns
    
    # Compute speedup function. Must be exactly 1 sim with Ns = min_Ns after averaging,
    # i.e. must have simID = Ns so that all sims with Ns = 1 are averaged over.
    i_serial = int(np.where(Ns==min_Ns)[0])
    sweeps_serial = rep_av_sweeps_mean[i_serial]
    psi = np.ones(Nsim)*sweeps_serial / rep_av_sweeps_mean

    # Compute uncertainty on speedup function by propagating the uncertainty
    # on the mean sweep using the functional approach
    psi_plus_err = np.ones(Nsim)*sweeps_serial / \
            (rep_av_sweeps_mean+rep_av_sweeps_stderr)
    psi_err = np.abs(psi - psi_plus_err)

    # Compute fit parameters
    coeffs = np.polyfit(Ns, psi, 1)
    fit = Ns*coeffs[0] + coeffs[1]
    

    # ----------------------- #
    #  Plot speedup function  #
    # ----------------------- #
    # Create plot
    fig, ax = plt.subplots()
    ax.tick_params(direction='in', top=True, right=True)
    ax.set_xlabel(r"$\sqrt{Ns}$")
    ax.set_ylabel(r"$\psi$")
    ax.set_title("Speedup function")

    # Add text to show the F value
    rootNs = np.sqrt(Ns)
    coords = (rootNs[0], np.max(psi))
    ax.text(coords[0], coords[1], \
            "Comparing sweeps to \nreach $F-1=$ %1.1e" %(F-1))

    # Plot data
    ax.errorbar(rootNs, psi, yerr=psi_err, fmt='ko')
    ax.plot(rootNs, fit, 'r--')



plt.show()

