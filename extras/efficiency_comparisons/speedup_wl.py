"""
Script.

Compare how quickly different Wang Landau simulations converge to their final F value.

Input data is generated by running      ./get_data.sh wl    in an appropriate directory.

Argument variables provide the input files.
Multiple simulations with the same simID (set in params.py) will be averaged over.

Run as e.g.     python compare_wl.py file1.txt file2.txt
"""

import numpy as np
import matplotlib.pyplot as plt
from sys import argv, exit

# Import information on input files, simulation data from sim_info.py (make sure it's correct!)
import sim_info

# Generic plot parameters
plt.rc('text', usetex=True)
font = {'family' : 'serif',
        'size' : 14}
plt.rc('font', **font)
colors = ('b', 'g', 'm', 'c')

# Create plot
fig, ax = plt.subplots()
ax.tick_params(direction='in', top=True, right=True)
ax.set_xlabel(r"$\sqrt{Ns}$")
ax.set_ylabel(r"$\psi$")
ax.set_title("Speedup function")
ax.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

# Input file names given as arguments
input_files = argv[1:]
Nfiles = len(input_files)

# Quick check
if Nfiles == 0:
    print "Error: Please provide one or more input files as arguments"
    exit(1)


# Iterate over input files
for ifile in range(Nfiles):

    # Initialise lists
    simID = []
    F_final = []
    Ns = []
    sweeps_alls = []

    print "Reading data from file: ", input_files[ifile]

    # Open file and read data
    # (Not using np.loadtxt since number of sweeps/cols can vary)
    with open(input_files[ifile]) as f:
        for line in f:
            
            # Convert line from string to list of floats
            line_float = map(float, line.split())

            # Append single numbers to lists
            simID.append(line_float[0])
            F_final.append(line_float[1])
            Ns.append(line_float[2])

            # Sort out sweeps using numpy arrays and append to lists
            sweeps_array = np.array(line_float[3:])
            sweeps_alls.append(sweeps_array)

    # Check that all simulations have converged to the same F
    F_final = np.array(F_final)
    if np.min(F_final) != np.max(F_final):
        print "Error: simulations have converged to different F values"
        exit(1)
    F = F_final[0]

    # Initialise lists to hold averages over repeats
    sweeps_rmean_alls = []
    sweeps_rmean_smean = []
    sweeps_rmean_serr = []

    unique_Ns = []
    N_repeats = []
    unique_simID = np.sort(np.array(list(set(simID)), dtype=int)) # low->high simID
    simID = np.array(simID, dtype=int) # convert to int for usid == sid expression
    
    # ----------------------------- #
    #  Iterate over unique simID's  #
    # ----------------------------- #
    for usid in unique_simID:

        # List of row numbers with this value of simID (reps to be averaged over)
        index_list = [i for i, sid in enumerate(simID) if usid == sid]
        i0 = index_list[0]
        print "Averaging over %d simulations for simID: %d (%s)" \
                %(len(index_list), usid, sim_info.sim_labels[usid])

        # Keep track of the number of sims we're averaging over
        N_repeats.append(len(index_list))

        # Assume repeats have same Ns - pretty safe to assume
        unique_Ns.append(Ns[i0])
    
        # Pull out the sweeps to be averaged over
        data_to_average = [] # store values for each repeat, subdomain
        for i in index_list:
            data_to_average.append(sweeps_alls[i])
    
        # Data in form (rows, cols) = (repeats, subdoms)
        data_to_average = np.array(data_to_average)

        # Average over repeats, subdoms still separate (useful to see trends)
        sweeps_rmean_alls.append( np.mean(data_to_average, axis=0) )
    
        # Average over repeats AND subdoms
        data_to_average = data_to_average.flatten()
        sweeps_rmean_smean.append( np.mean(data_to_average) )
        sweeps_rmean_serr.append( np.std(data_to_average) / np.sqrt(len(data_to_average)) )

    
    # End loop over unique values of simID


    # Rename things for convenience and convert to arrays of ints
    Ns = np.array(unique_Ns, dtype=int)
    simID = np.array(unique_simID, dtype=int)

    # Convert averaged data to arrays
    sweeps_rmean_smean = np.array(sweeps_rmean_smean)
    sweeps_rmean_serr = np.array(sweeps_rmean_serr)


    # -------------------------- #
    #  Compute speedup function  #
    # -------------------------- #
    # Maybe we calculate speedup relative to Np =/= 1 processors
    min_Ns = np.min(Ns)
    print "Computing speedup function defined as:  psi(Np) = X(%d)/X(Np),  (X: sweeps)" %min_Ns

    
    # There must be exactly 1 sim with Ns = min_Ns after averaging,
    # i.e. must have simID = Ns so that all sims with Ns = 1 are averaged over.
    i_serial = np.where(Ns==min_Ns)[0]
    if len(i_serial) > 1:
        print "Error: more than one unique simID with Ns = %d found in this file." %min_Ns
        print "Unsure which one to use as the 'serial' run in speedup function calculation."
        print "Use multiple files to separate different simulation types with the same Ns."
        exit(1)
    
    # Compute speedup function.
    i_serial = int(i_serial)
    sweeps_serial = sweeps_rmean_smean[i_serial]
    psi = np.ones(Nsim)*sweeps_serial / sweeps_rmean_smean

    # Compute uncertainty on speedup function by propagating the uncertainty
    # on the mean sweep using the functional approach
    psi_plus_err = np.ones(Nsim)*sweeps_serial / \
            (sweeps_rmean_smean + sweeps_rmean_serr)
    psi_err = np.abs(psi - psi_plus_err)

    # Compute fit parameters
    coeffs = np.polyfit(Ns, psi, 1)
    fit = Ns*coeffs[0] + coeffs[1]
   

    # ------------- #
    #  Add to plot  #
    # ------------- #
    # Add text to show the F value
    rootNs = np.sqrt(Ns)
    coords = (rootNs[0], np.max(psi))
    ax.text(coords[0], coords[1], \
            "Comparing sweeps to \nreach $F-1=$ %1.1e" %(F-1))

    # Input file is a key to access dictionary, value describes the simulation
    label = sim_info.file_labels[input_files[ifile]]
  
    # Plot data
    ax.errorbar(rootNs, psi, yerr=psi_err, fmt=colors[ifile]+'o', label=label)
    ax.plot(rootNs, fit, 'r--')


# End loop over input files


ax.legend()
plt.tight_layout()
plt.show()

