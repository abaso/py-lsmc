"""
Script.

Compare how quickly different 'dF' (multicanonical/transition matrix) simulations converge on
a result for the free energy difference between the two lattices.

Input data is generated by running      ./get_data.sh dF    in an appropriate directory.

Note that multiple simulations with the same simID (set in params.py) will be averaged over,
rather than compared.

Argument variables give the type of comparison to make:
No argument variable: Compares the values and uncertainties on dF for different simulations.
                      They must have run for the same number of sweeps!
                      Input file = "dF_data.txt"

argv[1] == 'std': Compare standard deviation as a function of sweeps for different simulations.
                  Input file = "stdev_series.txt"

argv[1] == 'psi': Compute the speedup function.
                  Input file = "stdev_series.txt"

Run as e.g.     python compare_dF.py std
"""

import numpy as np
import matplotlib.pyplot as plt
from sys import argv, exit

# Import information on input files, simulation data from sim_info.py (make sure it's correct!)
import sim_info

# Generic plot parameters
plt.rc('text', usetex=True)
font = {'family' : 'serif',
        'size' : 14}
plt.rc('font', **font)
colors = ('b', 'g', 'm', 'c')

# Create plot for standard deviation
fig1, ax1 = plt.subplots()
ax1.tick_params(direction='in', top=True, right=True)
ax1.set_xlabel("Sweeps")
ax1.set_ylabel(r"$\log_{10}{(\sigma_{\Delta F)}}$")
ax1.set_title("Std dev of a moving window for individual simulations")

# Create plot for mean deltaF
fig2, ax2 = plt.subplots()
ax2.tick_params(direction='in', top=True, right=True)
ax2.set_xlabel("Sweeps")
ax2.set_ylabel(r"$\bar{\Delta F}$")
ax2.set_title("Mean $\Delta F$")

# Create plot for standard error on mean
fig3, ax3 = plt.subplots()
ax3.tick_params(direction='in', top=True, right=True)
ax3.set_xlabel("Sweeps")
ax3.set_ylabel(r"$\sigma_{\Delta F} / \sqrt{N_{rep}}$")
ax3.set_title(r"Std error on $\bar{\Delta F}$")

# Input file names given as arguments
input_files = argv[1:]
Nfiles = len(input_files)

# Quick check
if Nfiles == 0:
    print "Error: Please provide one or more input files as arguments"
    exit(1)


# Iterate over input files
for ifile in range(Nfiles):

    # Initialise lists to hold data from all repeats
    simID = []
    Ns = []
    window = []
    sweeps_per_s = []
    dF_mean_allr = []
    dF_stdev_allr = []
    
    # Read input data
    print "Reading data fom file ", input_files[ifile]
    input_data = np.loadtxt(input_files[ifile])
    
    # Look for lines with Ns = -1 in second col
    # These separate data from different simulations
    new_sim_rows = np.where( input_data[:,1] == -1 )[0]
    Nsim = len(new_sim_rows)

    # Separate data from different simulations 
    rlo = 0
    for i in range(Nsim):
        rhi = int(new_sim_rows[i])
        
        simID.append(input_data[rlo,0])
        Ns.append(input_data[rlo,1])
        window.append(input_data[rlo,2])
        sweeps_per_s.append(input_data[rlo+1:rhi,0])
        dF_mean_allr.append(input_data[rlo+1:rhi,1])
        dF_stdev_allr.append(input_data[rlo+1:rhi,2])

        rlo = rhi + 1

    # Initialise lists for averages over repeats
    unique_sweeps_per_s = []
    dF_mean_rmean = []
    dF_mean_rerr = []
    dF_stdev_rmean = []
    dF_stdev_rerr = []
    
    unique_Ns = []
    N_repeats_list = []
    unique_simID = np.sort(np.array(list(set(simID)), dtype=int)) # low->high simID
    simID = np.array(simID, dtype=int) # convert to int for usid == sid expression


    # ----------------------------- #
    #  Iterate over unique simID's  #
    # ----------------------------- #
    for usid in unique_simID:

        # Find indices corresponding to repeats to be averaged over
        index_list = [i for i, sid in enumerate(simID) if usid == sid]
        index_list = np.array(index_list)
        i0 = index_list[0]

        # Keep track of the number of sims we're averaging over
        N_repeats = len(index_list)
        N_repeats_list.append(N_repeats)
        print "Averaging over %d simulations for simID: %d (%s)" \
                %(N_repeats, usid, sim_info.sim_labels[usid])

        # Assume repeats have same Ns - pretty safe to assume
        unique_Ns.append(Ns[i0])

        # Skip the averaging if only one sim
        if N_repeats == 1:
            unique_sweeps_per_s.append( sweeps_per_s[i0] )
            dF_mean_rmean.append( dF_mean_allr[i0] )
            dF_mean_rerr.append( np.zeros(len(dF_mean_allr[i0]) )
            dF_stdev_rmean.append( dF_stdev_allr[i0] )
            dF_stdev_rerr.append( np.zeros(len(dF_stdev_allr[i0])) )
            continue

        # Sweeps array taken from simulation with the most sweeps
        max_sweeps = 0
        i_max_sweeps = 0
        for i in index_list:
            if sweeps_per_s[i][-1] > max_sweeps:
                i_max_sweeps = i

        # Require repeats to have been sampled at the same frequency of sweeps
        unique_sweeps_per_s.append( sweeps_per_s[i_max_sweeps])
       
        # Create wierd array so we can take averages over data of different lengths
        max_len = len(sweeps_per_s[i_max_sweeps])
        dF_mean_to_average = np.ma.empty( (max_len, N_repeats) ) # (rows=sweeps, cols=sims)
        dF_mean_to_average.mask = True
        dF_stdev_to_average = np.ma.empty( (max_len, N_repeats) ) # (rows=sweeps, cols=sims)
        dF_stdev__average.mask = True

        # Fill in array with mean, stdev values
        for j in range(len(index_list)):
            i = index_list[j]

            this_mean_data = dF_mean_allr[i]
            this_stdev_data = dF_stdev_allr[i]

            dF_mean_to_average[:this_mean_data.shape[0],j] = this_mean_data
            dF_stdev_to_average[:this_stdev_data.shape[0],j] = this_stdev_data

        # Average over repeats for each value of sweeps
        dF_mean_averaged = np.array( dF_mean_to_average.mean(axis=1) )
        dF_stdev_averaged = np.array( dF_stdev_to_average.mean(axis=1) )
        dF_mean_err = np.array( dF_mean_to_average.std(axis=1) ) / np.sqrt(N_repeats)
        dF_stdev_err = np.array( dF_stdev_to_average.std(axis=1) ) / np.sqrt(N_repeats)
        
        # Add to list of averages for all simID
        dF_mean_rmean.append(dF_mean_averaged)
        dF_stdev_rmean.append(dF_stdev_averaged)

        # Append error on the mean to list
        dF_mean_rerr.append( dF_mean_err )
        dF_stdev_rerr.append( dF_stdev_err )
     
        
    # End loop of unique simID's
    

    # Rename things for convenience and convert to arrays of ints
    Ns = np.array(unique_Ns, dtype=int)
    simID = np.array(unique_simID, dtype=int)
    sweeps_per_s = unique_sweeps_per_s
    Nsim = len(simID) # now this is number of sims after averaging


    # -------------- #
    #  Add to plots  #
    # -------------- #
    # Input file is a key to access dictionary, value describes the simulation
    label = sim_info.file_labels[ input_files[ifile] ]

    i = 0 # int for indexing lists
    for sid in simID: # sorted list of ints, but may have gaps, so not interchangeable with i
        
        # Simulation label and N repeats in legend
        ilabel = sim_info.sim_labels[sid] + " (" + str(N_repeats_list[i]) + " repeats)"
        ilabel = label + ": " + ilabel
        
        # ------------------------- #
        #  Standard deviation plot  #
        # ------------------------- #
        # log plot is clearer
        logdata = np.log10(dF_stdev_rmean[i])
        
        # Propagate errors on logdata
        logdata_plus_err = np.log10(dF_stdev_rmean[i] + dF_stdev_rerr[i])
        logdata_err = np.abs(logdata_plus_err - logdata)
        
        # Sometimes it's clearer without the error bars...
        logdata_err = np.zeros(len(logdata))
        
        ax1.errorbar(sweeps_per_s[i], logdata, yerr=logdata_err, fmt='-', label=ilabel)
        
        # ------------------ #
        #  Mean deltaF plot  #
        # ------------------ #
        #error_to_plot = dF_mean_rerr[i]
        error_to_plot = np.zeros(len(dF_mean_rmean[i]))
        
        ax2.error(sweeps_per_s[i], dF_mean_rmean[i], yerr=error_to_plot, fmt='-', label=ilabel)

        # -------------------- #
        #  Error on mean plot  #
        # -------------------- #
        ax3.plot(sweeps_per_s[i], dF_mean_rerr[i], '-', label=ilabel)

        
        i += 1


# End loop over input files


ax.legend()
plt.tight_layout()
plt.show()

