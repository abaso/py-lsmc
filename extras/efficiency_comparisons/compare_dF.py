"""
Script.

Compare how quickly different 'dF' (multicanonical/transition matrix) simulations converge on
a result for the free energy difference between the two lattices.

Input data is generated by running      ./get_data.sh dF    in an appropriate directory.

Note that multiple simulations with the same simID (set in params.py) will be averaged over,
rather than compared.

Argument variables give the type of comparison to make:
No argument variable: Compares the values and uncertainties on dF for different simulations.
                      They must have run for the same number of sweeps!
                      Input file = "dF_data.txt"

argv[1] == 'std': Compare standard deviation as a function of sweeps for different simulations.
                  Input file = "stdev_series.txt"

argv[1] == 'psi': Compute the speedup function.
                  Input file = "stdev_series.txt"

Run as e.g.     python compare_dF.py std
"""

import numpy as np
import matplotlib.pyplot as plt
from sys import argv, exit

# Import information on input files, simulation data from sim_info.py (make sure it's correct!)
import sim_info

# Generic plot parameters
plt.rc('text', usetex=True)
font = {'family' : 'serif',
        'size' : 14}
plt.rc('font', **font)
colors = ('b', 'g', 'm', 'c')

# Create plot
fig, ax = plt.subplots()
ax.tick_params(direction='in', top=True, right=True)
ax.set_xlabel(sim_info.axis_label)
ax.set_ylabel("dF")
ax.set_title("Comparison of dF simulations")

# Sort out ticks and labels on categoric axis
fake_xticks = np.arange(len(sim_info.sim_labels))
ax.set_xticks(fake_xticks)
ax.set_xticklabels(sim_info.sim_labels)

# Input file names given as arguments
input_files = argv[1:]
Nfiles = len(input_files)

# Quick check
if Nfiles == 0:
    print "Error: Please provide one or more input files as arguments"
    exit(1)


# Iterate over input files
for ifile in range(Nfiles):

    print "Reading data from file: ", input_files[ifile]

    # Load data
    input_data = np.loadtxt(input_files[ifile])
    simID = input_data[:,0]
    Ns = input_data[:,1]
    sweeps_per_s = input_data[:,2]
    dF_mean = input_data[:,3]
    dF_stdev = input_data[:,4]
    dF_stderr = input_data[:,5]

    # Check that all simulations have run for the same Nsweeps
    if np.min(sweeps_per_s) != np.max(sweeps_per_s):
        print "Error: simulations have run for different Nsweeps"
        exit(1)


    # ------------------------------------------ #
    #  Average over simulations with same simID  #
    # ------------------------------------------ #
    unique_simID = np.array(list(set(simID)), dtype=int)
    simID = np.array(simID, dtype=int) # convert to int for usid == sid expression
    
    unique_Ns = []
    dF_mean_rmean = []
    dF_stderr_rmean = []
    N_repeats_list = []

    # Iterate over unique simulation ID's
    for usid in unique_simID:

        # Find indices corresponding to repeats to be averaged over
        index_list = [i for i, sid in enumerate(simID) if usid == sid]
        index_list = np.array(index_list)
        i0 = index_list[0]

        # Keep track of the number of sims we're averaging over
        N_repeats = len(index_list)
        N_repeats_list.append(N_repeats)
        print "Averaging over %d simulations for simID: %d (%s)" \
                %(len(index_list), usid, sim_info.sim_labels[usid])

        # Assume repeats have same Ns - pretty safe to assume
        unique_Ns.append(Ns[i0])

        # Pull out the values to be averaged over
        dF_mean_allr = dF_mean[ index_list ]
        dF_stderr_allr = dF_stdev[ index_list ]

        # Take average dF over repeats
        dF_mean_rmean.append(np.mean(dF_mean_allr))

        # Propagate error on dF
        err_on_sum = np.sqrt(np.sum(dF_stderr_allr**2)) # Add individual errors in quadrature
        dF_stderr_rmean.append( err_on_sum / N_repeats )


    # End loop over unique values of simID


    # ------------- #
    #  Add to plot  #
    # ------------- #
    # Input file is a key to access dictionary, value desribes the simulation
    label = sim_info.file_labels[ input_files[ifile] ]
    
    # Plot mean and standard error
    ax.errorbar(fake_xticks[unique_simID], dF_mean_rmean, yerr=dF_stderr_rmean, fmt=colors[ifile]+'o', label=label)


# End loop over input files


ax.legend()
plt.tight_layout()
plt.show()

